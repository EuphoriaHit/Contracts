// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

//This smart contract's reward distribution algorithm was based on this article
//https://uploads-ssl.webflow.com/5ad71ffeb79acc67c8bcdaba/5ad8d1193a40977462982470_scalable-reward-distribution-paper.pdf

/*
NOTE FOR PEOPLE WHO WILL EXAMINE THE CODE. THIS CONTRACT IS MAIN STAKING SYSTEM 
IN EUPHORIA APPLICATION, THERE ARE TWO WAYS TO PARTICIPATE IN STAKING SYSTEM:
    1) DIRECTLY THROUGH THE CALL OF THIS CONTRACT
    2) VIA LP STAKING CONTRACT. LP STAKING CONTRACT MAKES IT POSSIBLE FOR USERS
    TO PROVIDE LIQUIDITY ON PANCAKESWAP. IF USER BECOMES A LIQUIDITY PROVIDER (LP),
    THEN HE AUTOMATICALLY BECOMES A PARTICIPATOR OF BASE STAKING SYSTEM (WHICH IS THIS CONTRACT)

THAT'S WHY THERE ARE TWO SAME METHODS FOR DIFFERENT TYPE OF USERS createStake()/createStakeLP() and unStake()/unStakeLP()
THIS IS DONE TO SEPERATE LP USERS FROM ORDINARY STAKER USERS. HOWEVER, EUPHORIA USER CAN BE BOTH LP AND NORMAL STAKER AT THE SAME TIME

** THE FOLLOWING EXAMPLE APPLIES TO USERS WHO DECIDE TO STAKE TOKENS USING 2 METHODS TOGETHER **

IF USER STAKES 15 000 TOKENS VIA METHOD 1 AND ANOTHER 10 000 TOKENS VIA METHOD 2, THEN HIS TOTAL STAKES AMOUNT WILL BE EQUAL TOO 25 000
AND HE WILL GAIN REWARDS BASED ON HIS TOTAL STAKE AMOUNT. IT MEANS THAT, EVEN THOUGH USER'S NORMAL STAKES AMOUNT AND LP STAKES AMOUNT
ARE DIFFERENT AND SEPERATED, THEY ARE COMBINED WHEN IT COMES TO UNSTAKE. 

HAVING OUR ABOVE EXAMPLE IN MIND, WHEN USER UNSTAKES VIA unStake() METHOD, THEN HE WILL UNSTAKE HIS FULL REWARD FOR HIS TOTAL STAKE OF 25 000 TOKENS.
HOWEVER, HIS 10 000 TOKENS LEFT FROM LP STAKING WILL CONTINUE EARNING REWARDS FROM THE BEGINNING. SINCE THE USER HAVE UNSTAKED HIS NORMAL STAKE PART VIA unStake() METHOD,
IN ORDER TO UNSTAKE HIS LEFT 10 000 TOKENS, HE HAS TO UNSTAKE IT VIA unStakeLP() METHOD

IF THE USER UNSTAKES WHEN THE CONTRACT DURATION IS EXPIRED, THEN HIS REMAINING STAKED TOKENS (IF THERE ARE ANY) ARE BURNED AND HE STILL WILL RECEIVE THE FULL REWARD AMOUNT 

isLP BOOLEAN CHECK IN METHODS REPRESENT IF THE INITIATOR OF CALL WAS USER OR LP STAKING CONTRACT
*/

contract Staking is Ownable{
    using SafeERC20 for IERC20;
    uint64 constant PRECISION = 1000000000000;

    modifier contractExpired() {
        uint256 currentDay = _getCurrentDay();
        if(_totalStakes == 0) {
            _daysInPause += currentDay - _lastActiveDay;
            _lastActiveDay = currentDay;
        }
        require(currentDay - _daysInPause >= _contractDurationInDays, "Staking: The staking contract is not yet expired");
        _;
    }

    modifier contractNotExpired() {
        uint256 currentDay = _getCurrentDay();
        if(_totalStakes == 0) {
            _daysInPause += currentDay - _lastActiveDay;
            _lastActiveDay = currentDay;
        }
        require(currentDay - _daysInPause < _contractDurationInDays, "Staking: The staking contract has already expired");
        _;
    }

    modifier contractStarted() {
        require(_stakingStarted == true, "Staking: The staking contract has not started yet");
        _;
    }

    modifier contractNotStarted() {
        require(_stakingStarted == false, "Staking: The staking contract has already started");
        _;
    }

    // <================================ CONSTRUCTOR AND INITIALIZER ================================>

    constructor(uint256 supplyPercentage, uint16 durationInDays, address tokenAddress) {
        _setToken(tokenAddress);
        _setSupplyAndDuration(supplyPercentage, durationInDays);
    }

    function changeSupplyAndDuration(uint256 supplyPercentage, uint16 durationInDays) external onlyOwner contractNotStarted {
        _setSupplyAndDuration(supplyPercentage, durationInDays);
    }

    function changeToken(address newTokenAddress) external onlyOwner contractNotStarted{
        _setToken(newTokenAddress);
    }

    function changeLpStakingContract(address newContractAddress) external onlyOwner {
        _setLpStakingContract(newContractAddress);
    }

    function initialize()
        external
        onlyOwner
        contractNotStarted
    {
        require(_stakingStarted == false, "Staking: The staking contract has been already initialized");
        _stakingStarted = true;
        _startDate = block.timestamp - (block.timestamp % 1 days );
        transferTokensToContract(_initialSupply);
    }

    // <================================ END OF CONSTRUCTOR AND INITIALIZER ================================>
    IERC20 private _token;
    bool private _stakingStarted; // The boolean to check if the staking contract has been initialized and started the work process
    bool private _distributionEnded; // This boolean is used to control the work of distribuiteRewards() function
    address private _lpStakingContractAddress;
    uint256 public _contractDurationInDays; // Duration of contract in days
    mapping(address => mapping(uint256 => uint256)) private _distributedRewardsSnapshot; // S0 value in the Article Paper
    mapping(address => mapping(uint256 => uint256)) private _stake; // Keeps record of user's made stakings. Note that every new staking is considered as a seperate _stake transaction
    mapping(address => uint256) public _userTotalStakes; // Total amount of normal stakes of user
    mapping(address => uint256) public _userLpTotalStakes; // Total amount of normal stakes of user called by LP staking contract
    mapping(address => uint256) private _stakesCount; // Total number of accomplished stakes by a specific user
    mapping(address => uint16) private _stakedDay;
    uint256 private _distributedRewards; // S value in the Article Paper
    uint256 public _dailyReward; // Amount of tokens that will be distributed among all users in 1 Day 
    uint256 public _initialSupply; // Amount of tokens allocated for Staking contract use
    uint256 public _startDate; // Timestamp of the start day of the contract
    uint256 public _totalStakes; // Represents the total amount of staked Tokens. T value in the Article Paper. Find source of the article on top comment
    uint256 private _previousTotalStakes; // Represents the previous state of total amount of staked Tokens 
    uint256 private _lastActiveDay; // Represents the day of last activity such as createStake, unStake
    uint256 public _stakeHoldersCount; // Total number of stake holders (users)
    uint256 public _daysInPause; // Number of days with no active stakes. If there were no stakes on a specific day, then no reward is distributed and the duration of contract is extended to plus one day
    uint256 private _totalRewards; // The total amount of rewards that have already been distributed
    
    // <================================ EVENTS ================================>
    event StakeCreated(address indexed stakeHolder, uint256 indexed stake);

    event UnStaked(address indexed stakeHolder, uint256 indexed withdrawAmount);

    event TokensTransferedToStakingBalance(address indexed sender, uint256 indexed amount);

    // <================================ EXTERNAL FUNCTIONS ================================>

    // <<<================================= GETTERS =================================>>>
    //THIS IS A CALL FUNCTION THAT RETURNS THE EXPECTED REWARD VALUE THAT USER WILL RECEIVE 
    function calculateReward(bool isLP) external contractStarted view returns (uint256) {
        address _stakeHolder = _msgSender();
        uint256 userStakesCount = _stakesCount[_stakeHolder];
        uint256 reward;
        uint256 distributedRewards = _distributedRewards;
        uint256 withdrawAmount;
        uint256 totalDeposited;
        uint256 currentDay = _getCurrentDay();
        uint256 passedDays;
        require(isStakeHolder(_stakeHolder), "Staking: This user must be a stake holder");

        // Same code as in distributeRewards() method. However, it does not alter contract's state
        if(!_distributionEnded)
        {
            if(_lastActiveDay != currentDay || _lastActiveDay != _contractDurationInDays + _daysInPause){
                if (currentDay - _daysInPause > _contractDurationInDays) {
                    passedDays = _contractDurationInDays - (_lastActiveDay - _daysInPause);
                } else {
                    passedDays = currentDay - _lastActiveDay;
                }

                distributedRewards += (_dailyReward * passedDays * PRECISION) / _previousTotalStakes;
            }
        }

        // Calculation of User reward
        for(uint i = 0; i < userStakesCount; i++) {
            uint256 deposited = _stake[_stakeHolder][i];
            reward += (deposited * (distributedRewards - _distributedRewardsSnapshot[_stakeHolder][i])) / PRECISION;
            totalDeposited += deposited;
        }

        if(reward > 0) {
            withdrawAmount = isLP ? reward : reward + totalDeposited;
        } else {
            withdrawAmount = isLP ? 0 : totalDeposited;
        }

        return withdrawAmount;
    }

    function canUserUnstake(address stakeHolder) external view returns(bool) {
        return _getCurrentDay() > _stakedDay[stakeHolder];
    }

    function getUserStakesAmount(address stakeHolder) external view returns(uint256) {
        uint256 result;

        for(uint i = 0; i < _stakesCount[stakeHolder]; i++) {
            result += _stake[stakeHolder][i];
        }

        return result;
    }

    // <<<================================= END OF GETTERS =================================>>>

    function transferTokensToContract(uint256 amount) public onlyOwner
    {
        address owner = _msgSender();
        _token.safeTransferFrom(owner, address(this), amount);
        emit TokensTransferedToStakingBalance(owner, amount);
    }

   function isStakeHolder(address stakeholder) public view returns(bool) {
        if(_stakesCount[stakeholder] != 0) {
            return true;
        }
       
       return false;
   }

    function createStake(uint256 stakeAmount)
       external
       contractStarted
       contractNotExpired
       returns (bool) 
    {
        address sender = _msgSender();
        _token.safeTransferFrom(sender, address(this), stakeAmount);
        require(_createStake(sender, stakeAmount, false), "Staking: Couldn't create stake");

        return true;
    }

    function createStakeLP(address stakeHolder, uint256 stakeAmount)
       external
       contractStarted
       contractNotExpired
       returns (bool) 
    {
        require(_msgSender() == _lpStakingContractAddress, "Staking: This method can only called by LP Staking contract");
        require(_createStake(stakeHolder, stakeAmount, true), "Staking: Couldn't create stake");

        return true;
    }

    function unStake()
        external
        contractStarted
        returns (bool)
    {
        address sender = _msgSender();
        require(isStakeHolder(sender), "Staking: There is not any stake holder with provided address");
        require(_userTotalStakes[sender] > 0, "Staking: This user does not have any active stakes");
        return _unStake(sender, false);
    }

    function unStakeLP(address stakeHolder)
        external
        contractStarted
        returns (bool)
    {
        address sender = _msgSender();
        require(sender == _lpStakingContractAddress, "Staking: This method can only called by LP Staking contract");
        require(isStakeHolder(sender), "Staking: There is not any stake holder with provided address");
        require(_userLpTotalStakes[sender] > 0, "Staking: This user does not have any active stakes");
        return _unStake(stakeHolder, true);
    }

    function finalize() external onlyOwner contractStarted contractExpired {
        address owner = _msgSender();
        uint256 balanceEUPH = _token.balanceOf(address(this));
        if(balanceEUPH > 0)  _token.safeTransfer(owner, balanceEUPH);
        selfdestruct(payable(owner));
    }

    // <================================ INTERNAL FUNCTIONS ================================>

    function decimals() internal pure returns(uint8) {
        return 3;
    }

    function toKiloToken(uint256 amount) internal pure returns(uint256) {
        return amount * (10 ** decimals());
    }

    function balanceOfContract()
       internal
       view
       returns(uint256)
   {
       return _token.balanceOf(address(this));
   }

    // <================================ PRIVATE FUNCTIONS ================================>

    function removeStakeHolder(address stakeHolder, bool isLP) private contractStarted {
        for(uint i = 0; i < _stakesCount[stakeHolder]; i++) {
            delete _stake[stakeHolder][i];
            delete _distributedRewardsSnapshot[stakeHolder][i];
        }
        delete _stakesCount[stakeHolder];
        isLP ? delete _userLpTotalStakes[stakeHolder] : delete _userTotalStakes[stakeHolder];
        
        delete _stakedDay[stakeHolder];
        _stakeHoldersCount -= 1;
   }

   function _setSupplyAndDuration(uint256 supplyPercentage, uint16 durationInDays) private {
       require(durationInDays > 0, "Staking: Duration cannot be a zero value");
       require(supplyPercentage > 0 && supplyPercentage <= 100, "Staking: Supply percentage can be in a range between 0 and 100");
        _contractDurationInDays = durationInDays;
        _initialSupply = (_token.totalSupply() * supplyPercentage) / 100;
        _dailyReward = _initialSupply / _contractDurationInDays;
   }

   function _setToken(address newTokenAddress) private {
        require(
            address(_token) != newTokenAddress,
            "Staking: Cannot change token of same address"
        );
        _token = IERC20(newTokenAddress);
    }

    function _setLpStakingContract(address newContractAddress) private {
        require(
            _lpStakingContractAddress != newContractAddress,
            "Staking: Cannot change contract of same address"
        );
        _lpStakingContractAddress = newContractAddress;
    }

    function _getCurrentDay() private view returns (uint256) 
    {
        return (block.timestamp - _startDate) / 1 days;    
    }

    function _distributeRewards()
        private
    {
        uint256 currentDay = _getCurrentDay();
        uint256 passedDays;

        if(_lastActiveDay == currentDay || _lastActiveDay == _contractDurationInDays + _daysInPause) return;
        
        if (currentDay - _daysInPause > _contractDurationInDays) {
            _distributionEnded = true;
            passedDays = _contractDurationInDays - (_lastActiveDay - _daysInPause);
        } else {
            passedDays = currentDay - _lastActiveDay;
        }

        _distributedRewards += (_dailyReward * passedDays * PRECISION) / _previousTotalStakes;

        _lastActiveDay = currentDay;
    }

    function _createStake(address stakeHolder, uint256 stakeAmount, bool isLP) private returns (bool) {
        require(stakeHolder != address(0), "Staking: No zero address is allowed");
        require(stakeAmount >= toKiloToken(10000), "Staking: Minimal stake value is 10 000 euphoria tokens");
        uint256 stakeId = _stakesCount[stakeHolder];
        uint256 currentDay = _getCurrentDay();

        if(!isStakeHolder(stakeHolder))
        { 
            _stakeHoldersCount += 1;
            _stakedDay[stakeHolder] = uint16(currentDay);
        }
        if(!_distributionEnded) {
            if(currentDay != _lastActiveDay)
            {
                _distributeRewards();
            }
        }

        _stake[stakeHolder][stakeId] = stakeAmount;
        _distributedRewardsSnapshot[stakeHolder][stakeId] = _distributedRewards;
        _stakesCount[stakeHolder] += 1;
        
        if(isLP){
            _userLpTotalStakes[stakeHolder] += stakeAmount;
        } else {
            _userTotalStakes[stakeHolder] += stakeAmount;
        }
        
        _totalStakes += stakeAmount;

        if(_previousTotalStakes == 0 || currentDay == _lastActiveDay) {
            _previousTotalStakes = _totalStakes;
        }

        emit StakeCreated(stakeHolder, stakeAmount);

        return true;
   }

   function _unStake(address stakeHolder, bool isLP) private returns (bool) {
        require(stakeHolder != address(0), "Staking: Zero address is prohibited");
        require(isStakeHolder(stakeHolder), "Staking: There is not any stake holder with provided address");
        uint256 userStakesCount = _stakesCount[stakeHolder];
        uint256 reward;
        uint256 withdrawAmount;
        uint256 totalDeposited;
        uint256 totalStakesAmount = _userTotalStakes[stakeHolder];
        uint256 lpTotalStakesAmount = _userLpTotalStakes[stakeHolder];

        if(!_distributionEnded)
        {
            if(_getCurrentDay() != _lastActiveDay) {
                _distributeRewards();
            }
        }

        // Calculation of User reward
        for(uint i = 0; i < userStakesCount; i++) {
            uint256 deposited = _stake[stakeHolder][i];
            reward += (deposited * (_distributedRewards - _distributedRewardsSnapshot[stakeHolder][i])) / PRECISION;
            totalDeposited += deposited;
        }

        _totalStakes -= isLP ? lpTotalStakesAmount : totalStakesAmount;
        _previousTotalStakes = _totalStakes;

        if(reward > 0) {
            _totalRewards += reward;
            withdrawAmount = isLP ? reward : reward + totalDeposited;
        } else {
            withdrawAmount = isLP ? 0 : totalDeposited;
        }

        if(withdrawAmount != 0) { _token.safeTransfer(stakeHolder, withdrawAmount); }

        removeStakeHolder(stakeHolder, isLP);
        
        if((_userTotalStakes[stakeHolder] != 0 || _userLpTotalStakes[stakeHolder] != 0) && !_isContractExpired())
        {
            if(isLP) {
                if(totalStakesAmount != 0) {
                    _stake[stakeHolder][0] = totalStakesAmount;
                    _userTotalStakes[stakeHolder] = totalStakesAmount;
                }
            } else {
                if(lpTotalStakesAmount != 0) {
                    _stake[stakeHolder][0] = lpTotalStakesAmount;
                    _userLpTotalStakes[stakeHolder] = lpTotalStakesAmount;
                }
            }

            _distributedRewardsSnapshot[stakeHolder][0] = _distributedRewards;
            _stakesCount[stakeHolder] = 1;
            _stakeHoldersCount += 1;
        }

        emit UnStaked(stakeHolder, withdrawAmount);

        return true;
    }

    function _isContractExpired() private view returns(bool) {
        return _getCurrentDay() - _daysInPause >= _contractDurationInDays;
    }
}